# 枚举重构迁移指南

## 概述

为了提高代码的类型安全性和可维护性，已将 `Constants` 类中的静态常量类重构为枚举（enum）实现，并新增了 `DefaultAvatar` 枚举来管理默认头像。

## 变更内容

### 1. Constants 类枚举化

以下静态常量类已转换为枚举：

- `CodeType` - 验证码类型
- `UserStatus` - 用户状态
- `Gender` - 性别
- `ShopStatus` - 商家状态
- `NoteStatus` - 笔记状态
- `CommentStatus` - 评论状态
- `MessageType` - 消息类型
- `NoticeType` - 通知类型
- `BrowseTargetType` - 浏览目标类型
- `FavoriteType` - 收藏类型
- `ErrorCode` - 错误码

### 2. 新增 DefaultAvatar 枚举

创建了独立的 `DefaultAvatar` 枚举类来管理系统默认头像。

### 3. 保留的静态类

以下配置类仍保持静态常量形式（因为它们是配置值，不需要枚举）：

- `SmsCode` - 短信验证码配置
- `RedisKey` - Redis Key前缀
- `CacheExpire` - 缓存过期时间
- `Page` - 分页默认值

## API 变更对照表

### 枚举类型使用方法

#### 旧的使用方式（已废弃）

```java
// 获取整型值
int loginType = Constants.CodeType.LOGIN;  // ❌ 不再支持

// 错误码
int errorCode = Constants.ErrorCode.PHONE_FORMAT_ERROR;  // ❌ 不再支持
```

#### 新的使用方式

```java
// 获取枚举值
Constants.CodeType loginType = Constants.CodeType.LOGIN;  // ✅ 推荐

// 获取整型code
int code = Constants.CodeType.LOGIN.getCode();  // ✅ 获取整型值

// 获取描述
String desc = Constants.CodeType.LOGIN.getDesc();  // ✅ 获取描述

// 错误码使用
int errorCode = Constants.ErrorCode.PHONE_FORMAT_ERROR.getCode();  // ✅ 获取错误码
String errorMsg = Constants.ErrorCode.PHONE_FORMAT_ERROR.getMessage();  // ✅ 获取错误消息
```

### 具体示例

#### 1. CodeType（验证码类型）

```java
// 旧方式
int type = Constants.CodeType.LOGIN;  // 返回: 1

// 新方式
Constants.CodeType type = Constants.CodeType.LOGIN;
int code = type.getCode();  // 返回: 1
String desc = type.getDesc();  // 返回: "登录"

// 可用枚举值
Constants.CodeType.LOGIN           // 登录 (1)
Constants.CodeType.REGISTER        // 注册 (2)
Constants.CodeType.RESET_PASSWORD  // 重置密码 (3)
Constants.CodeType.CHANGE_PHONE_OLD  // 修改手机号-验证原手机 (4)
Constants.CodeType.CHANGE_PHONE_NEW  // 修改手机号-验证新手机 (5)
```

#### 2. UserStatus（用户状态）

```java
// 旧方式
user.setStatus(Constants.UserStatus.NORMAL);  // 设置为 1

// 新方式
user.setStatus(Constants.UserStatus.NORMAL.getCode());  // 设置为 1

// 可用枚举值
Constants.UserStatus.NORMAL    // 正常 (1)
Constants.UserStatus.DISABLED  // 禁用 (2)
```

#### 3. ErrorCode（错误码）

```java
// 旧方式
throw new BusinessException(Constants.ErrorCode.PHONE_FORMAT_ERROR, "手机号格式错误");

// 新方式 - 方式1：分别获取code和message
Constants.ErrorCode error = Constants.ErrorCode.PHONE_FORMAT_ERROR;
throw new BusinessException(error.getCode(), error.getMessage());

// 新方式 - 方式2：直接使用
throw new BusinessException(
    Constants.ErrorCode.PHONE_FORMAT_ERROR.getCode(),
    Constants.ErrorCode.PHONE_FORMAT_ERROR.getMessage()
);

// 可用枚举值
Constants.ErrorCode.PHONE_FORMAT_ERROR  // 手机号格式错误 (40001)
Constants.ErrorCode.CODE_ERROR          // 验证码错误或已过期 (40002)
Constants.ErrorCode.USER_NOT_FOUND      // 用户不存在 (40003)
// ... 等等
```

### DefaultAvatar（默认头像）使用

#### 旧的使用方式（已废弃）

```java
// AuthServiceImpl.java 中的旧代码
private static final String[] DEFAULT_AVATARS = {
    "https://cheng-9.oss-cn-beijing.aliyuncs.com/head_photo/headphoto/head1.png",
    // ... 其他头像
};
private static final Random RANDOM = new Random();

private String getRandomAvatar() {
    int index = RANDOM.nextInt(DEFAULT_AVATARS.length);
    return DEFAULT_AVATARS[index];
}
```

#### 新的使用方式

```java
import com.businessreviews.common.DefaultAvatar;

// 随机获取一个头像URL
String avatarUrl = DefaultAvatar.getRandomAvatar();

// 获取所有头像URL数组
String[] allAvatars = DefaultAvatar.getAllAvatarUrls();

// 获取特定头像
String avatar1 = DefaultAvatar.AVATAR_1.getUrl();
String avatar2 = DefaultAvatar.AVATAR_2.getUrl();
// ... AVATAR_3 到 AVATAR_10
```

## 迁移步骤

### 步骤 1: 导入新类

如果使用了 `DefaultAvatar`，需要添加导入：

```java
import com.businessreviews.common.DefaultAvatar;
```

### 步骤 2: 更新代码

查找所有使用旧常量的地方，根据上述对照表更新代码。

### 步骤 3: 编译检查

重新编译项目，确保没有编译错误：

```bash
cd backend-business-reviews
mvn clean compile
```

## 优势

### 1. 类型安全

```java
// 旧方式 - 不安全，可能传入错误的整数
public void setType(int type) { }
setType(999);  // 编译通过，但是无效值

// 新方式 - 类型安全
public void setType(Constants.CodeType type) { }
setType(Constants.CodeType.LOGIN);  // ✅ 只能传入有效枚举值
setType(999);  // ❌ 编译错误
```

### 2. 代码可读性

```java
// 旧方式 - 需要查看常量定义才知道含义
if (user.getStatus() == 1) { }

// 新方式 - 一目了然
if (user.getStatus() == Constants.UserStatus.NORMAL.getCode()) { }
```

### 3. IDE 支持

- 自动补全所有可用枚举值
- 快速查看枚举值的描述
- 重构更安全（IDE 可以追踪所有引用）

### 4. 集中管理

所有默认头像集中在 `DefaultAvatar` 枚举中，便于维护和扩展。

## 最佳实践

### 1. 数据库存储

数据库中仍然存储整型值：

```java
// 设置到数据库
user.setStatus(Constants.UserStatus.NORMAL.getCode());  // 存储 1

// 从数据库读取后比较
if (user.getStatus() == Constants.UserStatus.NORMAL.getCode()) {
    // 用户状态正常
}
```

### 2. 枚举转换

如果需要根据整型值获取枚举：

```java
// 示例：根据code获取枚举
public static Constants.CodeType getCodeTypeByCode(int code) {
    for (Constants.CodeType type : Constants.CodeType.values()) {
        if (type.getCode() == code) {
            return type;
        }
    }
    return null;
}
```

### 3. JSON 序列化

如果使用 Jackson，枚举默认序列化为枚举名称。如需序列化为 code，可添加注解：

```java
@JsonValue  // 序列化时使用此方法的返回值
public int getCode() {
    return code;
}
```

## 常见问题

### Q1: 为什么不把 RedisKey 也改成枚举？

A: `RedisKey` 是字符串前缀，用于动态拼接，不适合用枚举。枚举适合有限的、固定的选项。

### Q2: 如何在 MyBatis XML 中使用枚举？

```xml
<!-- 直接使用 getCode() 方法 -->
<if test="status == @com.businessreviews.common.Constants$UserStatus@NORMAL.getCode()">
    AND status = #{status}
</if>
```

### Q3: 旧代码会立即失效吗？

A: 不会。枚举改造是向后兼容的，但建议尽快迁移到新的 API。

## 修改文件清单

### 新增文件
- `backend-business-reviews-common/src/main/java/com/businessreviews/common/DefaultAvatar.java`

### 修改文件
- `backend-business-reviews-common/src/main/java/com/businessreviews/common/Constants.java`
- `backend-business-reviews-service/src/main/java/com/businessreviews/service/impl/AuthServiceImpl.java`
- `backend-business-reviews-web/src/main/java/com/businessreviews/controller/AuthController.java`

## 总结

这次重构使代码更加类型安全、可维护和易读。建议在后续开发中：

1. ✅ 使用枚举代替魔法数字
2. ✅ 利用枚举的 `getCode()` 和 `getDesc()` 方法
3. ✅ 使用 `DefaultAvatar.getRandomAvatar()` 获取随机头像
4. ✅ 保持配置类（如 `RedisKey`）的静态常量形式

如有任何问题，请参考本文档或联系开发团队。
